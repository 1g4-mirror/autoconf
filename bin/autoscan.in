#! @PERL@ -w
# -*- perl -*-
# autoscan - Create configure.scan (a preliminary configure.ac) for a package.
# Copyright 1994, 1999, 2000, 2001 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

# Written by David MacKenzie <djm@gnu.ai.mit.edu>.

use 5.005;
require "find.pl";
use Getopt::Long;
use strict;

use vars qw($autoconf $datadir $initfile $me $name $verbose
            @cfiles @makefiles @shfiles %c_keywords %printed);

($me = $0) =~ s,.*/,,;
$verbose = 0;

# $USED{KIND}{ITEM} is set if ITEM is used in the program.
# It is set to its list of locations.
my %used = ();

# $MACRO{KIND}{ITEM} is the macro to use to test ITEM.
my %macro = ();

# $NEEDED_MACROS{MACRO} is an array of locations requiring MACRO.
my %needed_macros = ();

my @kinds = qw (functions headers identifiers programs makevars libraries);

# For each kind, the default macro.
my %generic_macro =
  (
   'functions'   => 'AC_CHECK_FUNCS',
   'headers'     => 'AC_CHECK_HEADERS',
   'identifiers' => 'AC_CHECK_TYPES',
   'programs'    => 'AC_CHECK_PROGS',
   'libraries'   => 'AC_CHECK_LIB'
  );

my %kind_comment =
  (
   'functions' => 'Checks for library functions.',
   'headers' => 'Checks for header files.',
   'identifiers' => 'Checks for typedefs, structures, and compiler characteristics.',
   'programs' => 'Checks for programs.',
  );

my $configure_scan = 'configure.scan';


# Exit nonzero whenever closing STDOUT fails.
sub END
{
  use POSIX qw (_exit);
  # This is required if the code might send any output to stdout
  # E.g., even --version or --help.  So it's best to do it unconditionally.
  close STDOUT
    or (warn "$me: closing standard output: $!\n"), _exit (1);
}

# find_autoconf
# -------------
# Find the lib files and autoconf.
sub find_autoconf
{
  $datadir = $ENV{"AC_MACRODIR"} || "@datadir@";
  (my $dir = $0) =~ s,[^/]*$,,;
  $autoconf = '';
  # We test "$dir/autoconf" in case we are in the build tree, in which case
  # the names are not transformed yet.
  foreach my $file ($ENV{"AUTOCONF"} || '',
		    "$dir/@autoconf-name@",
		    "$dir/autoconf",
		    "@bindir@/@autoconf-name@")
    {
      if (-x $file)
	{
	  $autoconf = $file;
	  last;
	}
    }
}


# $CONFIGURE_AC
# &find_configure_ac ()
# ---------------------
sub find_configure_ac ()
{
  if (-f 'configure.ac')
    {
      if (-f 'configure.in')
	{
	  warn "warning: `configure.ac' and `configure.in' both present.\n";
	  warn "warning: proceeding with `configure.ac'.\n";
	}
      return 'configure.ac';
    }
  elsif (-f 'configure.in')
    {
      return 'configure.in';
    }
  return;
}


# print_usage ()
# --------------
# Display usage (--help).
sub print_usage ()
{
  print "Usage: $0 [OPTION] ... [SRCDIR]

Examine source files in the directory tree rooted at SRCDIR, or the
current directory if none is given.  Search the source files for
common portability problems and create a file `$configure_scan' which
is a preliminary `configure.ac' for that package.

  -h, --help            print this help, then exit
  -V, --version         print version number, then exit
  -v, --verbose         verbosely report processing

Library directories:
  -A, --autoconf-dir=ACDIR  Autoconf's files location (rarely needed)
  -l, --localdir=DIR        location of `aclocal.m4' and `acconfig.h'

Report bugs to <bug-autoconf\@gnu.org>.\n";
  exit 0;
}


# print_version ()
# ----------------
# Display version (--version).
sub print_version
{
  print "autoscan (@PACKAGE_NAME@) @VERSION@
Written by David J. MacKenzie.

Copyright 1994, 1999, 2000, 2001 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
  exit 0;
}


# parse_args ()
# -------------
# Process any command line arguments.
sub parse_args ()
{
  my $srcdir;
  Getopt::Long::config ("bundling");
  Getopt::Long::GetOptions ("A|autoconf-dir|m|macrodir=s" => \$datadir,
			    "h|help" => \&print_usage,
			    "V|version" => \&print_version,
			    "v|verbose" => \$verbose)
    or exit 1;

  die "$me: too many arguments
Try `$me --help' for more information.\n"
    if (@ARGV > 1);
  ($srcdir) = @ARGV;
  $srcdir = "."
    if !defined $srcdir;

  print "srcdir=$srcdir\n" if $verbose;
  chdir $srcdir || die "$me: cannot cd to $srcdir: $!\n";
}


# init_tables ()
# --------------
# Put values in the tables of what to do with each token.
sub init_tables ()
{
  # Initialize a table of C keywords (to ignore).
  # Taken from K&R 1st edition p. 180.
  # ANSI C, GNU C, and C++ keywords can introduce portability problems,
  # so don't ignore them.

  foreach (qw (int char float double struct union long short unsigned
	       auto extern register typedef static goto return sizeof break
	       continue if else for do while switch case default))
    {
      $c_keywords{$_} = 0;
    }

  # The data file format supports only one line of macros per function.
  # If more than that is required for a common portability problem,
  # a new Autoconf macro should probably be written for that case,
  # instead of duplicating the code in lots of configure.ac files.

  foreach my $kind (@kinds)
    {
      my $file = "$datadir/ac$kind";
      open TABLE, $file or
	die "$me: cannot open $file: $!\n";
      while (<TABLE>)
	{
	  # Ignore blank lines and comments.
	  next
	    if /^\s*$/ || /^\s*\#/;
	  unless (/^(\S+)\s+(\S.*)$/ || /^(\S+)\s*$/)
	    {
	      die "$me: cannot parse definition in $file:\n$_\n";
	    }
	  my $word = $1;
	  my $macro = $2 || $generic_macro{$kind};
	  $macro{$kind}{$word} = $macro;
	}
      close(TABLE);
    }
}


# wanted ()
# ---------
# Collect names of various kinds of files in the package.
# Called by &find on each file.
sub wanted ()
{
  # Strip a useless leading `./'.
  $name =~ s,^\./,,;

  if (/^.*\.[chlymC]$/ || /^.*\.cc$/)
    {
      push (@cfiles, $name);
    }
  elsif (/^[Mm]akefile$/ || /^GNUmakefile$/)
    {
      # Wanted only if there is no corresponding Makefile.in.
      # Using Find, $_ contains the current filename with the current
      # directory of the walk through.
      push (@makefiles, $name)
	if ! -f "$_.in";
    }
  elsif (/^[Mm]akefile\.in$/)
    {
      push (@makefiles, $name);
    }
  elsif (/^.*\.sh$/)
    {
      push (@shfiles, $name);
    }
}


# scan_files ()
# -------------
# Read through the files and collect lists of tokens in them
# that might create nonportabilities.
sub scan_files ()
{
  my $file;
  if (defined $cfiles[0])
    {
      $initfile = $cfiles[0];		# Pick one at random.
    }

  foreach $file (@cfiles)
    {
      push (@{$used{'programs'}{"cc"}}, $file);
      scan_c_file ($file);
    }

  foreach $file (@makefiles)
    {
      scan_makefile ($file);
    }

  foreach $file (@shfiles)
    {
      scan_sh_file ($file);
    }

  if ($verbose)
    {
      print "cfiles:", join(" ", @cfiles), "\n";
      print "makefiles:", join(" ", @makefiles), "\n";
      print "shfiles:", join(" ", @shfiles), "\n";

      foreach my $kind (@kinds)
	{
	  print "\n$kind:\n";
	  foreach my $word (sort keys %{$used{$kind}})
	    {
	      print "$word: @{$used{$kind}{$word}}\n";
	    }
	}
    }
}


# scan_c_file(FILE)
# -----------------
sub scan_c_file ($)
{
  my ($file) = @_;
  my ($in_comment) = 0;	# Nonzero if in a multiline comment.

  open(CFILE, "<$file") || die "$me: cannot open $file: $!\n";
  while (<CFILE>)
    {
      # Strip out comments, approximately.
      # Ending on this line.
      if ($in_comment && m,\*/,)
	{
	  s,.*\*/,,;
	  $in_comment = 0;
	}
      # All on one line.
      s,/\*.*\*/,,g;
      # Starting on this line.
      if (m,/\*,)
	{
	  $in_comment = 1;
	}
      # Continuing on this line.
      next if $in_comment;

      # Preprocessor directives.
      if (/^\s*\#\s*include\s*<([^>]*)>/)
	{
	  push (@{$used{'headers'}{$1}}, "$file:$.");
	}
      # Ignore other preprocessor directives.
      next if /^\s*\#/;

      # Remove string and character constants.
      s,\"[^\"]*\",,g;
      s,\'[^\']*\',,g;

      # Tokens in the code.
      # Maybe we should ignore function definitions (in column 0)?
      while (s/\b([a-zA-Z_]\w*)\s*\(/ /)
	{
	  push (@{$used{'functions'}{$1}}, "$file:$.")
	    if !defined $c_keywords{$1};
	}
      while (s/\b([a-zA-Z_]\w*)\b/ /)
	{
	  push (@{$used{'identifiers'}{$1}}, "$file:$.")
	    if !defined $c_keywords{$1};
	}
    }
  close(CFILE);
}


# scan_makefile(MAKEFILE)
# -----------------------
sub scan_makefile ($)
{
  my ($file) = @_;

  open(MFILE, "<$file") || die "$me: cannot open $file: $!\n";
  while (<MFILE>)
    {
      # Strip out comments and variable references.
      s/#.*//;
      s/\$\([^\)]*\)//g;
      s/\${[^\}]*}//g;
      s/@[^@]*@//g;

      # Variable assignments.
      while (s/\b([a-zA-Z_]\w*)\s*=/ /)
	{
	  push (@{$used{'makevars'}{$1}}, "$file:$.");
	}
      # Libraries.
      while (s/\B-l([a-zA-Z_]\w*)\b/ /)
	{
	  push (@{$used{'libraries'}{$1}}, "$file:$.");
	}
      # Tokens in the code.
      while (s/\b([a-zA-Z_]\w*)\b/ /)
	{
	  push (@{$used{'programs'}{$1}}, "$file:$.");
	}
    }
  close(MFILE);
}


# scan_sh_file(SHELL-SCRIPT)
# --------------------------
sub scan_sh_file ($)
{
  my ($file) = @_;

  open(MFILE, "<$file") || die "$me: cannot open $file: $!\n";
  while (<MFILE>)
    {
      # Strip out comments and variable references.
      s/#.*//;
      s/\${[^\}]*}//g;
      s/@[^@]*@//g;

      # Tokens in the code.
      while (s/\b([a-zA-Z_]\w*)\b/ /)
	{
	  push (@{$used{'programs'}{$1}}, "$file:$.");
	}
    }
  close(MFILE);
}


# print_unique ($KIND, $WORD)
# ---------------------------
# $WORD, of some $KIND, is used, and needs to be checked.  (i) output
# the needed macro invocation in $configure_scan if it exists and
# hasn't been printed already, (ii), remember this macro needed.
sub print_unique ($@)
{
  my ($kind, $word) = @_;

  my $macro = $macro{$kind}{$word};
  my @where = @{$used{$kind}{$word}};

  if (defined $macro && !defined $printed{$macro})
    {
      print CONF "$macro\n";
      $printed{$macro} = 1;

      push (@{$needed_macros{$macro}}, @where);
    }
}


# output_kind ($KIND)
# -------------------
sub output_kind ($)
{
  my ($kind) = @_;
  my @have;

  print CONF "\n# $kind_comment{$kind}\n"
    if exists $kind_comment{$kind};
  foreach my $word (sort keys %{$used{$kind}})
    {
      if (defined $macro{$kind}{$word})
	{
	  if (exists $generic_macro{$kind}
	      && $macro{$kind}{$word} eq $generic_macro{$kind})
	    {
	      push (@have, $word);
	      push (@{$needed_macros{"$generic_macro{$kind}([$word])"}},
		    @{$used{$kind}{$word}});
	    }
	  else
	    {
	      print_unique ($kind, $word);
	    }
	}
    }
  print CONF "$generic_macro{$kind}([" . join(' ', sort(@have)) . "])\n"
    if @have;
}


# output_libraries ()
# -------------------
sub output_libraries ()
{
  print CONF "\n# Checks for libraries.\n";
  foreach my $word (sort keys %{$used{'libraries'}})
    {
      print CONF "# FIXME: Replace `main' with a function in `-l$word':\n";
      print CONF "AC_CHECK_LIB([$word], [main])\n";
    }
}


# output (CONFIGURE_SCAN)
# -----------------------
# Print a proto configure.ac.
sub output ($)
{
  my $configure_scan = shift;
  my %unique_makefiles;

  open (CONF, ">$configure_scan") ||
    die "$me: cannot create $configure_scan: $!\n";

  print CONF "# Process this file with autoconf to produce a configure script.\n";
  print CONF "AC_INIT\n";
  if (defined $initfile)
    {
      print CONF "AC_CONFIG_SRCDIR([$initfile])\n";
    }
  if (defined $cfiles[0])
    {
      print CONF "AC_CONFIG_HEADER([config.h])\n";
    }

  output_kind ('programs');
  output_kind ('makevars');
  output_libraries;
  output_kind ('headers');
  output_kind ('identifiers');
  output_kind ('functions');

  # Change DIR/Makefile.in to DIR/Makefile.
  foreach my $m (@makefiles)
    {
      $m =~ s/\.in$//;
      $unique_makefiles{$m}++;
    }
  print CONF "\nAC_CONFIG_FILES([",
       join ("\n                 ", keys(%unique_makefiles)), "])\n";
  print CONF "AC_OUTPUT\n";

  close CONF ||
    die "$me: closing $configure_scan: $!\n";
}


# check_configure_ac (CONFIGURE_AC)
# ---------------------------------
# Use autoconf to check if all the suggested macros are included
# in CONFIGURE_AC.
sub check_configure_ac ($)
{
  my ($configure_ac) = $@;
  my ($trace_option) = '';

  foreach my $macro (sort keys %needed_macros)
    {
      $macro =~ s/\(.*//;
      $trace_option .= " -t $macro";
    }

  open (TRACES, "$autoconf -A $datadir $trace_option $configure_ac|") ||
    die "$me: cannot create read traces: $!\n";

  while (<TRACES>)
    {
      chomp;
      my ($file, $line, $macro, @args) = split (/:/, $_);
      if ($macro =~ /^AC_CHECK_(HEADER|FUNC|TYPE|MEMBER)S$/)
	{
	  # To be rigorous, we should distinguish between space and comma
	  # separated macros.  But there is no point.
	  foreach my $word (split (/\s|,/, $args[0]))
	    {
	      # AC_CHECK_MEMBERS wants `struct' or `union'.
	      if ($macro eq "AC_CHECK_MEMBERS"
		  && $word =~ /^stat.st_/)
		{
		  $word = "struct " . $word;
		}
	      delete ($needed_macros{"$macro([$word])"});
	    }
	}
      else
	{
	  delete ($needed_macros{$macro});
	}
    }

  close (TRACES) ||
    die "$me: cannot close traces: $!\n";

  foreach my $macro (sort keys %needed_macros)
    {
      warn "$me: warning: missing $macro wanted by: \n";
      foreach my $need (@{$needed_macros{$macro}})
        {
          warn "\t$need\n";
        }
    }
}


## -------------- ##
## Main program.  ##
## -------------- ##

# Find the lib files and autoconf.
find_autoconf;
my $configure_ac = find_configure_ac;
parse_args;
init_tables;
find ('.');
scan_files;
output ('configure.scan');
if ($configure_ac)
  {
    check_configure_ac ($configure_ac);
  }

exit 0;
